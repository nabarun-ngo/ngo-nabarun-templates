name: Resolve Inputs
description: Merge inputs from workflow_dispatch, repository_dispatch, and schedule triggers into a single JSON output

inputs:
  inputs:
    description: JSON string of workflow_dispatch inputs (optional). If empty, auto-detect via github.event.inputs
    required: false
    default: ''
  client_payload:
    description: JSON string of repository_dispatch client_payload (optional). If empty, auto-detect via github.event.client_payload
    required: false
    default: ''
  schedule_config_file:
    description: Path to JSON config file for scheduled workflows (optional). Used when github.event_name is 'schedule'
    required: false
    default: ''


outputs:
  variables:
    description: Merged inputs as a JSON string (supports workflow_dispatch, repository_dispatch, and schedule triggers)
    value: ${{ steps.final.outputs.variables }}
  trigger_type:
    description: The type of trigger that initiated the workflow (workflow_dispatch, repository_dispatch, schedule, etc.)
    value: ${{ steps.resolve.outputs.trigger_type }}

runs:
  using: composite
  steps:
    - id: resolve
      name: Resolve and merge inputs based on trigger type
      shell: bash
      run: |
        set -euo pipefail
        
        # Detect trigger type
        event_name="${{ github.event_name }}"
        echo "Trigger type: $event_name"
        echo "trigger_type=$event_name" >> "$GITHUB_OUTPUT"
        
        # Initialize final_data
        final_data='{}'
        
        case "$event_name" in
          "workflow_dispatch")
            echo "ðŸ“ Processing workflow_dispatch trigger"
            inputs_json='${{ inputs.inputs != '' && inputs.inputs || toJson(github.event.inputs) }}'
            if [[ "$inputs_json" != "null" && "$inputs_json" != "{}" && ! -z "$inputs_json" ]]; then
              final_data="$inputs_json"
              echo "âœ… Using workflow_dispatch inputs"
            else
              echo "â„¹ï¸ No workflow_dispatch inputs found"
            fi
            ;;
            
          "repository_dispatch")
            echo "ðŸš€ Processing repository_dispatch trigger"
            payload_json='${{ inputs.client_payload != '' && inputs.client_payload || toJson(github.event.client_payload) }}'
            if [[ "$payload_json" != "null" && "$payload_json" != "{}" && ! -z "$payload_json" ]]; then
              final_data="$payload_json"
              echo "âœ… Using repository_dispatch payload"
            else
              echo "â„¹ï¸ No repository_dispatch payload found"
            fi
            ;;
            
          "schedule")
            echo "â° Processing schedule trigger"
            if [[ -n "${{ inputs.schedule_config_file }}" ]]; then
              config_file="${{ inputs.schedule_config_file }}"
              if [[ -f "$config_file" ]]; then
                echo "ðŸ“„ Reading schedule config from: $config_file"
                
                # Get the current schedule cron from github.event.schedule
                current_schedule="${{ github.event.schedule }}"
                echo "ðŸ“… Current schedule: $current_schedule"
                
                # Extract config for the current schedule from JSON
                schedule_config=$(cat "$config_file" | jq -c --arg schedule "$current_schedule" '.[$schedule] // {}')
                
                if [[ "$schedule_config" != "{}" ]]; then
                  final_data="$schedule_config"
                  echo "âœ… Found config for schedule '$current_schedule'"
                else
                  echo "âš ï¸ No config found for schedule '$current_schedule' in $config_file"
                  echo "Available schedules in config:"
                  cat "$config_file" | jq -r 'keys[]' | while read -r key; do
                    echo "  - \"$key\""
                  done
                  echo "Using empty config for schedule trigger"
                fi
              else
                echo "âŒ Schedule config file not found: $config_file"
                echo "Using empty config for schedule trigger"
              fi
            else
              echo "â„¹ï¸ No schedule config file specified"
              echo "Using empty config for schedule trigger"
            fi
            ;;
            
          *)
            echo "â“ Unknown or unsupported trigger type: $event_name"
            echo "Trying to resolve from available inputs..."
            
            # Fallback: try to get data from any available source
            inputs_json='${{ inputs.inputs != '' && inputs.inputs || toJson(github.event.inputs) }}'
            payload_json='${{ inputs.client_payload != '' && inputs.client_payload || toJson(github.event.client_payload) }}'
            
            if [[ "$payload_json" != "null" && "$payload_json" != "{}" && ! -z "$payload_json" ]]; then
              final_data="$payload_json"
              echo "âœ… Using fallback repository_dispatch payload"
            elif [[ "$inputs_json" != "null" && "$inputs_json" != "{}" && ! -z "$inputs_json" ]]; then
              final_data="$inputs_json"
              echo "âœ… Using fallback workflow_dispatch inputs"
            fi
            ;;
        esac
        
        # Ensure JSON is properly formatted
        final_data=$(echo "$final_data" | jq -c '.' || echo '{}')
        
        echo "Final merged data: $final_data"
        echo "variables=$final_data" >> "$GITHUB_OUTPUT"

    

    - name: Export final merged variables to GitHub environment
      shell: bash
      id: final
      run: |
        set -euo pipefail
        merged_json='${{ steps.resolve.outputs.variables }}'
        echo "$merged_json" | jq -r 'to_entries | map("\(.key)=\(.value|tostring)") | .[]' >> "$GITHUB_ENV"
        echo "variables=$merged_json" >> "$GITHUB_OUTPUT"

   
