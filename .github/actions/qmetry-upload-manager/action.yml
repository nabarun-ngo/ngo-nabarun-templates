name: 'QMetry Upload Manager'
description: 'Handles complete QMetry upload process including URL generation, file upload, and import tracking'
inputs:
  qmetry_api_key:
    description: 'QMetry API key for authentication'
    required: true
  test_environment:
    description: 'Test environment name'
    required: true
  test_cycle_summary:
    description: 'Summary for the test cycle'
    required: true
  test_cycle_folder:
    description: 'QMetry folder ID for test cycles'
    required: true
  test_case_folder:
    description: 'QMetry folder ID for test cases'
    required: true
  app_server_version:
    description: 'Server application version'
    required: true
  app_ui_version:
    description: 'UI application version'
    required: true
  test_type:
    description: 'Type of test being executed'
    required: true
  run_id:
    description: 'GitHub workflow run ID'
    required: true
  run_attempt:
    description: 'GitHub workflow run attempt number'
    required: true
  results_file_path:
    description: 'Path to the test results JSON file'
    required: true
  cached_test_cycle:
    description: 'Cached test cycle ID for reuse (optional)'
    required: false
    default: ''
  templates_repository:
    description: 'Templates repository containing scripts'
    required: false
    default: 'nabarun-ngo/ngo-nabarun-templates'
    
outputs:
  upload_url:
    description: 'Generated QMetry upload URL'
    value: ${{ steps.generate_upload_url.outputs.upload_url }}
  tracking_id:
    description: 'QMetry import tracking ID'
    value: ${{ steps.generate_upload_url.outputs.tracking_id }}
  upload_status:
    description: 'Status of file upload'
    value: ${{ steps.upload_file.outputs.status }}
  import_status:
    description: 'Status of QMetry import'
    value: ${{ steps.wait_import.outputs.import_status }}

runs:
  using: 'composite'
  steps:
    - name: Initialize QMetry upload
      shell: bash
      run: |
        echo "ğŸ“¡ Starting QMetry upload process..."
        echo "ğŸ“Š Upload Configuration:"
        echo "  Environment: ${{ inputs.test_environment }}"
        echo "  Test Type: ${{ inputs.test_type }}"
        echo "  Test Cycle Summary: ${{ inputs.test_cycle_summary }}"
        echo "  Results File: ${{ inputs.results_file_path }}"
        echo "  Run ID: ${{ inputs.run_id }}-${{ inputs.run_attempt }}"
        echo "  Server Version: ${{ inputs.app_server_version }}"
        echo "  UI Version: ${{ inputs.app_ui_version }}"
        
        if [[ -n "${{ inputs.cached_test_cycle }}" ]]; then
          echo "  ğŸ”„ Reusing Test Cycle: ${{ inputs.cached_test_cycle }}"
        else
          echo "  ğŸ†• Creating New Test Cycle"
        fi
        echo ""
        
    - name: Validate upload prerequisites
      shell: bash
      run: |
        echo "ğŸ” Validating upload prerequisites..."
        
        # Check if results file exists
        if [[ ! -f "${{ inputs.results_file_path }}" ]]; then
          echo "âŒ ERROR: Results file not found: ${{ inputs.results_file_path }}"
          echo "ğŸ“ Current directory contents:"
          ls -la . || echo "Could not list current directory"
          exit 1
        fi
        
        # Check file size and content
        FILE_SIZE=$(wc -c < "${{ inputs.results_file_path }}")
        echo "âœ… Results file validated:"
        echo "  ğŸ“„ Path: ${{ inputs.results_file_path }}"
        echo "  ğŸ“ Size: $FILE_SIZE bytes"
        
        if [[ $FILE_SIZE -lt 10 ]]; then
          echo "âš ï¸ WARNING: File size is very small ($FILE_SIZE bytes) - may be empty"
        fi
        
        # Check if file contains valid JSON
        if command -v jq >/dev/null 2>&1; then
          if jq empty "${{ inputs.results_file_path }}" 2>/dev/null; then
            echo "âœ… JSON validation passed"
          else
            echo "âŒ ERROR: Invalid JSON in results file"
            echo "ğŸ“„ First 200 characters of file:"
            head -c 200 "${{ inputs.results_file_path }}" || echo "Could not read file"
            exit 1
          fi
        fi
        
    - name: Checkout templates repository
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.templates_repository }}
        path: 'qmetry-templates'
        
    - name: Preprocess folder IDs
      id: preprocess_ids
      shell: bash
      run: |
        echo "ğŸ”§ Preprocessing folder IDs to ensure proper formatting..."
        
        # Remove any commas from folder IDs (in case of thousands separators)
        TEST_CYCLE_FOLDER="${{ inputs.test_cycle_folder }}"
        TEST_CASE_FOLDER="${{ inputs.test_case_folder }}"
        
        # Clean the values by removing commas and whitespace
        CLEAN_TEST_CYCLE_FOLDER=$(echo "$TEST_CYCLE_FOLDER" | tr -d ',[:space:]')
        CLEAN_TEST_CASE_FOLDER=$(echo "$TEST_CASE_FOLDER" | tr -d ',[:space:]')
        
        echo "ğŸ“Š Folder ID Processing:"
        echo "  Test Cycle Folder: '$TEST_CYCLE_FOLDER' -> '$CLEAN_TEST_CYCLE_FOLDER'"
        echo "  Test Case Folder: '$TEST_CASE_FOLDER' -> '$CLEAN_TEST_CASE_FOLDER'"
        
        # Validate that cleaned values are numeric
        if ! [[ "$CLEAN_TEST_CYCLE_FOLDER" =~ ^[0-9]+$ ]]; then
          echo "âŒ ERROR: Test cycle folder ID is not a valid number: '$CLEAN_TEST_CYCLE_FOLDER'"
          exit 1
        fi
        
        if ! [[ "$CLEAN_TEST_CASE_FOLDER" =~ ^[0-9]+$ ]]; then
          echo "âŒ ERROR: Test case folder ID is not a valid number: '$CLEAN_TEST_CASE_FOLDER'"
          exit 1
        fi
        
        # Set outputs
        echo "clean_test_cycle_folder=$CLEAN_TEST_CYCLE_FOLDER" >> $GITHUB_OUTPUT
        echo "clean_test_case_folder=$CLEAN_TEST_CASE_FOLDER" >> $GITHUB_OUTPUT
        
        echo "âœ… Folder IDs preprocessed successfully"
        
    - name: Generate QMetry upload URL
      id: generate_upload_url
      uses: fjogeleit/http-request-action@v1
      with:
        url: 'https://qtmcloud.qmetry.com/rest/api/automation/importresult'
        method: POST
        customHeaders: '{"Content-Type": "application/json","apiKey":"${{ inputs.qmetry_api_key }}"}'
        data: |
         {
            "format": "cucumber",
            "testCycleToReuse": "${{ inputs.cached_test_cycle }}",
            "attachFile": true,
            "isZip": false,
            "environment": "${{ inputs.test_environment }}",
            "matchTestSteps": true,
            "fields": {
              "testCycle": {
                "folderId": ${{ steps.preprocess_ids.outputs.clean_test_cycle_folder }},
                "summary": "${{ inputs.test_cycle_summary }}"
              },
              "testCase": {
                "priority": "High",
                "folderId": ${{ steps.preprocess_ids.outputs.clean_test_case_folder }}
              },
              "testCaseExecution": {
                "customFields": [
                  {
                    "name": "Run Id",
                    "value": "${{ inputs.run_id }}-${{ inputs.run_attempt }}"
                  },
                  {
                    "name": "Server Version",
                    "value": "${{ inputs.app_server_version }}"
                  },
                  {
                    "name": "UI Version",
                    "value": "${{ inputs.app_ui_version }}"
                  },
                  {
                    "name": "Test Type",
                    "value": "${{ inputs.test_type }}"
                  }
                ]
              }
            }
          }
          
    - name: Process upload URL response
      shell: bash
      run: |
        echo "ğŸ”— Processing QMetry upload URL response..."
        
        RESPONSE='${{ steps.generate_upload_url.outputs.response }}'
        echo "ğŸ“¡ QMetry API Response:"
        echo "$RESPONSE" | jq '.' || echo "Response: $RESPONSE"
        
        # Extract key information
        UPLOAD_URL=$(echo "$RESPONSE" | jq -r '.url // empty')
        TRACKING_ID=$(echo "$RESPONSE" | jq -r '.trackingId // empty')
        
        if [[ -z "$UPLOAD_URL" ]]; then
          echo "âŒ ERROR: No upload URL received from QMetry"
          echo "ğŸ“„ Full response: $RESPONSE"
          exit 1
        fi
        
        if [[ -z "$TRACKING_ID" ]]; then
          echo "âŒ ERROR: No tracking ID received from QMetry"
          echo "ğŸ“„ Full response: $RESPONSE"
          exit 1
        fi
        
        echo "âœ… QMetry upload URL generated successfully:"
        echo "  ğŸ”— Upload URL: $UPLOAD_URL"
        echo "  ğŸ·ï¸ Tracking ID: $TRACKING_ID"
        
    - name: Upload results file to QMetry
      id: upload_file
      shell: bash
      run: |
        echo "ğŸ“¤ Uploading results file to QMetry..."
        
        UPLOAD_URL='${{ fromJson(steps.generate_upload_url.outputs.response).url }}'
        RESULTS_FILE="${{ inputs.results_file_path }}"
        
        echo "ğŸš€ Starting file upload:"
        echo "  ğŸ“„ File: $RESULTS_FILE"
        echo "  ğŸ”— URL: $UPLOAD_URL"
        echo "  ğŸ“ File size: $(wc -c < "$RESULTS_FILE") bytes"
        
        # Perform upload with detailed logging
        HTTP_CODE=$(curl -w "%{http_code}" -s -o upload_response.txt \
          -X PUT \
          -H "Content-Type: multipart/form-data" \
          -H "User-Agent: PostmanRuntime/7.43.0" \
          -d "@$RESULTS_FILE" \
          "$UPLOAD_URL")
        
        echo "ğŸ“Š Upload completed:"
        echo "  ğŸ“¡ HTTP Code: $HTTP_CODE"
        
        if [[ -f "upload_response.txt" ]]; then
          echo "  ğŸ“„ Response:"
          cat upload_response.txt
        fi
        
        # Check if upload was successful
        if [[ "$HTTP_CODE" -ge 200 && "$HTTP_CODE" -lt 300 ]]; then
          echo "âœ… File upload successful (HTTP $HTTP_CODE)"
          echo "status=success" >> $GITHUB_OUTPUT
        else
          echo "âŒ File upload failed (HTTP $HTTP_CODE)"
          if [[ -f "upload_response.txt" ]]; then
            echo "ğŸ“„ Error response:"
            cat upload_response.txt
          fi
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi
        
    - name: Wait for QMetry import completion
      id: wait_import
      shell: bash
      run: |
        echo "â³ Waiting for QMetry import to complete..."
        
        TRACKING_ID='${{ fromJson(steps.generate_upload_url.outputs.response).trackingId }}'
        WAIT_SCRIPT="qmetry-templates/scripts/wait-for-qmetry-report-import.sh"
        
        echo "ğŸ“Š Import tracking:"
        echo "  ğŸ·ï¸ Tracking ID: $TRACKING_ID"
        echo "  ğŸ“œ Wait script: $WAIT_SCRIPT"
        
        # Verify wait script exists
        if [[ ! -f "$WAIT_SCRIPT" ]]; then
          echo "âŒ ERROR: Wait script not found: $WAIT_SCRIPT"
          echo "ğŸ“ Available scripts:"
          ls -la qmetry-templates/scripts/ || echo "Scripts directory not found"
          exit 1
        fi
        
        # Make script executable and run
        chmod +x "$WAIT_SCRIPT"
        
        echo "ğŸ• Starting import wait process..."
        if bash "$WAIT_SCRIPT" "$TRACKING_ID" "${{ inputs.qmetry_api_key }}"; then
          echo "âœ… QMetry import completed successfully"
          echo "import_status=completed" >> $GITHUB_OUTPUT
        else
          echo "âŒ QMetry import failed or timed out"
          echo "import_status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi
        
    - name: Upload summary
      shell: bash
      run: |
        echo "ğŸ“Š QMetry Upload Manager Summary:"
        echo "  âœ… Status: Success"
        echo "  ğŸ”— Upload URL: Generated successfully"
        echo "  ğŸ·ï¸ Tracking ID: ${{ fromJson(steps.generate_upload_url.outputs.response).trackingId }}"
        echo "  ğŸ“¤ Upload Status: ${{ steps.upload_file.outputs.status }}"
        echo "  ğŸ“¥ Import Status: ${{ steps.wait_import.outputs.import_status }}"
        echo "  ğŸ¯ Test Results: Successfully uploaded to QMetry"
        echo "ğŸ”„ Ready for result linking phase"
