name: 'GCP Download Logs'
description: 'Download logs from Google Cloud Logging with textPayload filter and multiple output format support'
author: 'Nabarun NGO'

inputs:
  project_id:
    description: 'GCP Project ID to query logs from'
    required: true
  filter:
    description: 'Log filter query (e.g., textPayload:"uuid-value")'
    required: true
  output_format:
    description: 'Output format for the logs'
    required: false
    default: 'txt'
  output_filename:
    description: 'Custom filename for output (without extension)'
    required: false
    default: ''
  time_range:
    description: 'Time range for log query (e.g., "timestamp>=\"2024-01-01T00:00:00Z\"")'
    required: false
    default: ''
  order_by:
    description: 'Field to order results by (default: desc)'
    required: false
    default: 'desc'
  limit:
    description: 'Maximum number of log entries to retrieve'
    required: false
    default: '10000'
  include_metadata:
    description: 'Include log metadata in output (severity, timestamp, etc.)'
    required: false
    default: 'true'

outputs:
  output_path:
    description: 'Path to the generated log file'
    value: ${{ steps.generate-filename.outputs.output_file }}
  log_count:
    description: 'Number of log entries retrieved'
    value: ${{ steps.fetch-logs.outputs.log_count }}
  query_summary:
    description: 'Summary of the executed query'
    value: ${{ steps.fetch-logs.outputs.query_summary }}
  execution_time:
    description: 'Time taken to execute the query'
    value: ${{ steps.fetch-logs.outputs.execution_time }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs and environment
      shell: bash
      run: |
        echo "üîç Validating GCP download logs inputs..."
        echo "üìù Project ID: ${{ inputs.project_id }}"
        echo "üîç Filter: ${{ inputs.filter }}"
        echo "üìÑ Output Format: ${{ inputs.output_format }}"
        echo "üìä Limit: ${{ inputs.limit }}"
        
        # Validate required gcloud CLI is available
        if ! command -v gcloud >/dev/null 2>&1; then
          echo "‚ùå gcloud CLI not found. Please ensure Google Cloud CLI is installed and authenticated."
          exit 1
        fi
        
        # Validate jq is available for JSON processing
        if ! command -v jq >/dev/null 2>&1; then
          echo "‚ùå jq not found. Please ensure jq is installed for JSON processing."
          exit 1
        fi
        
        # Validate output format
        case "${{ inputs.output_format }}" in
          txt|csv|html|json)
            echo "‚úÖ Valid output format: ${{ inputs.output_format }}"
            ;;
          *)
            echo "‚ùå Invalid output format: ${{ inputs.output_format }}"
            echo "   Supported formats: txt, csv, html, json"
            exit 1
            ;;
        esac
        
        echo "‚úÖ Input validation completed successfully"

    - name: Fetch logs from GCP
      id: fetch-logs
      shell: bash
      run: |
        echo "üì• Fetching logs from Google Cloud Logging..."
        START_TIME=$(date +%s)
        
        # Build the gcloud logging read command
        GCLOUD_CMD="gcloud logging read"
        
        # Add the main filter
        GCLOUD_CMD="$GCLOUD_CMD \"${{ inputs.filter }}\""
        
        # Add time range filter if provided
        if [[ -n "${{ inputs.time_range }}" ]]; then
          echo "‚è∞ Adding time range filter: ${{ inputs.time_range }}"
          GCLOUD_CMD="$GCLOUD_CMD AND ${{ inputs.time_range }}"
        fi
        
        # Add project, format, limit and order
        GCLOUD_CMD="$GCLOUD_CMD --project=\"${{ inputs.project_id }}\""
        GCLOUD_CMD="$GCLOUD_CMD --format=json"
        GCLOUD_CMD="$GCLOUD_CMD --limit=${{ inputs.limit }}"
        GCLOUD_CMD="$GCLOUD_CMD --order=\"${{ inputs.order_by }}\""
        
        echo "üîß Executing command: $GCLOUD_CMD"
        
        # Execute the command and save raw logs
        if ! eval "$GCLOUD_CMD" > raw_logs.json 2>error.log; then
          echo "‚ùå Failed to fetch logs from GCP"
          echo "Error details:"
          cat error.log || echo "No error details available"
          exit 1
        fi
        
        # Calculate execution time
        END_TIME=$(date +%s)
        EXECUTION_TIME=$((END_TIME - START_TIME))
        
        # Count log entries
        LOG_COUNT=$(jq length raw_logs.json 2>/dev/null || echo "0")
        
        echo "üìä Query Results:"
        echo "   - Log entries found: $LOG_COUNT"
        echo "   - Execution time: ${EXECUTION_TIME}s"
        
        # Create query summary
        QUERY_SUMMARY="Project: ${{ inputs.project_id }} | Filter: ${{ inputs.filter }} | Count: $LOG_COUNT | Time: ${EXECUTION_TIME}s"
        
        # Set outputs
        echo "log_count=$LOG_COUNT" >> "$GITHUB_OUTPUT"
        echo "execution_time=${EXECUTION_TIME}s" >> "$GITHUB_OUTPUT"
        echo "query_summary=$QUERY_SUMMARY" >> "$GITHUB_OUTPUT"
        
        if [[ "$LOG_COUNT" -eq 0 ]]; then
          echo "‚ö†Ô∏è No log entries found matching the filter criteria"
        else
          echo "‚úÖ Successfully fetched $LOG_COUNT log entries"
        fi

    - name: Generate output filename
      id: generate-filename
      shell: bash
      run: |
        echo "üìù Generating output filename..."
        
        # Determine output filename
        if [[ -n "${{ inputs.output_filename }}" ]]; then
          BASE_FILENAME="${{ inputs.output_filename }}"
        else
          # Create filename from filter (sanitized)
          FILTER_CLEAN=$(echo "${{ inputs.filter }}" | sed 's/[^a-zA-Z0-9-]/_/g' | cut -c1-50)
          BASE_FILENAME="gcp_logs_${FILTER_CLEAN}_$(date +%Y%m%d_%H%M%S)"
        fi
        
        OUTPUT_FILE="${BASE_FILENAME}.${{ inputs.output_format }}"
        echo "üìÅ Output filename: $OUTPUT_FILE"
        echo "output_file=$OUTPUT_FILE" >> "$GITHUB_OUTPUT"

    - name: Create TXT output
      if: ${{ inputs.output_format == 'txt' }}
      shell: bash
      env:
        OUTPUT_FILE: ${{ steps.generate-filename.outputs.output_file }}
      run: |
        echo "üìÑ Creating TXT output file: $OUTPUT_FILE"
        
        if [[ "${{ inputs.include_metadata }}" == "true" ]]; then
          echo "üîß Including metadata in TXT output"
          jq -r '.[] | "\(.timestamp) [\(.severity // "INFO")] \(.textPayload // .jsonPayload // "No message")"' raw_logs.json > "$OUTPUT_FILE"
        else
          echo "üîß Text-only output (no metadata)"
          jq -r '.[] | .textPayload // .jsonPayload // "No message"' raw_logs.json > "$OUTPUT_FILE"
        fi
        
        # Verify file creation and get size
        if [[ -f "$OUTPUT_FILE" ]]; then
          FILE_SIZE=$(stat -f%z "$OUTPUT_FILE" 2>/dev/null || stat -c%s "$OUTPUT_FILE" 2>/dev/null || echo "unknown")
          echo "‚úÖ TXT file created successfully: $OUTPUT_FILE (${FILE_SIZE} bytes)"
        else
          echo "‚ùå Failed to create TXT file"
          exit 1
        fi

    - name: Create CSV output
      if: ${{ inputs.output_format == 'csv' }}
      shell: bash
      env:
        OUTPUT_FILE: ${{ steps.generate-filename.outputs.output_file }}
      run: |
        echo "üìä Creating CSV output file: $OUTPUT_FILE"
        
        if [[ "${{ inputs.include_metadata }}" == "true" ]]; then
          echo "üîß Creating CSV with metadata columns"
          echo "Timestamp,Severity,Message,Resource,Labels" > "$OUTPUT_FILE"
          jq -r '.[] | [.timestamp, (.severity // "INFO"), (.textPayload // .jsonPayload // "No message"), (.resource.type // ""), (.labels | tostring // "")] | @csv' raw_logs.json >> "$OUTPUT_FILE"
        else
          echo "üîß Creating CSV with message only"
          echo "Message" > "$OUTPUT_FILE"
          jq -r '.[] | [(.textPayload // .jsonPayload // "No message")] | @csv' raw_logs.json >> "$OUTPUT_FILE"
        fi
        
        # Verify file creation and get size
        if [[ -f "$OUTPUT_FILE" ]]; then
          FILE_SIZE=$(stat -f%z "$OUTPUT_FILE" 2>/dev/null || stat -c%s "$OUTPUT_FILE" 2>/dev/null || echo "unknown")
          LINES=$(wc -l < "$OUTPUT_FILE" 2>/dev/null || echo "unknown")
          echo "‚úÖ CSV file created successfully: $OUTPUT_FILE (${FILE_SIZE} bytes, ${LINES} lines)"
        else
          echo "‚ùå Failed to create CSV file"
          exit 1
        fi

    - name: Create HTML output
      if: ${{ inputs.output_format == 'html' }}
      shell: bash
      env:
        OUTPUT_FILE: ${{ steps.generate-filename.outputs.output_file }}
      run: |
        echo "üåê Creating HTML output file: $OUTPUT_FILE"
        
        # Create HTML structure step by step to avoid heredoc issues
        echo '<!DOCTYPE html>' > "$OUTPUT_FILE"
        echo '<html>' >> "$OUTPUT_FILE"
        echo '<head>' >> "$OUTPUT_FILE"
        echo '    <meta charset="UTF-8">' >> "$OUTPUT_FILE"
        echo '    <title>GCP Logs Report</title>' >> "$OUTPUT_FILE"
        echo '    <style>' >> "$OUTPUT_FILE"
        echo '        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }' >> "$OUTPUT_FILE"
        echo '        .header { background: #4285f4; color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }' >> "$OUTPUT_FILE"
        echo '        .stats { background: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; display: flex; gap: 20px; }' >> "$OUTPUT_FILE"
        echo '        .stat-item { text-align: center; flex: 1; }' >> "$OUTPUT_FILE"
        echo '        .stat-value { font-size: 1.5em; font-weight: bold; color: #4285f4; }' >> "$OUTPUT_FILE"
        echo '        .log-entry { background: white; margin: 10px 0; padding: 15px; border-left: 4px solid #4285f4; border-radius: 4px; }' >> "$OUTPUT_FILE"
        echo '        .timestamp { color: #666; font-size: 0.9em; margin-bottom: 5px; }' >> "$OUTPUT_FILE"
        echo '        .severity { font-weight: bold; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; display: inline-block; margin-bottom: 8px; }' >> "$OUTPUT_FILE"
        echo '        .severity.INFO { background: #e8f0fe; color: #1967d2; }' >> "$OUTPUT_FILE"
        echo '        .severity.WARNING { background: #fef7e0; color: #f29900; }' >> "$OUTPUT_FILE"
        echo '        .severity.ERROR { background: #fce8e6; color: #d93025; }' >> "$OUTPUT_FILE"
        echo '        .message { margin-top: 8px; white-space: pre-wrap; font-family: monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; }' >> "$OUTPUT_FILE"
        echo '        .metadata { margin-top: 10px; font-size: 0.85em; color: #666; background: #f8f9fa; padding: 8px; border-radius: 4px; }' >> "$OUTPUT_FILE"
        echo '        .no-logs { text-align: center; padding: 40px; color: #666; font-style: italic; }' >> "$OUTPUT_FILE"
        echo '    </style>' >> "$OUTPUT_FILE"
        echo '</head>' >> "$OUTPUT_FILE"
        echo '<body>' >> "$OUTPUT_FILE"
        
        # Add header with project info
        echo '    <div class="header">' >> "$OUTPUT_FILE"
        echo '        <h1>üîç GCP Logs Report</h1>' >> "$OUTPUT_FILE"
        echo "        <p><strong>Project:</strong> ${{ inputs.project_id }}</p>" >> "$OUTPUT_FILE"
        echo "        <p><strong>Filter:</strong> ${{ inputs.filter }}</p>" >> "$OUTPUT_FILE"
        echo "        <p><strong>Generated:</strong> $(date)</p>" >> "$OUTPUT_FILE"
        echo '    </div>' >> "$OUTPUT_FILE"
        
        # Add stats section
        LOG_COUNT=$(jq length raw_logs.json)
        echo '    <div class="stats">' >> "$OUTPUT_FILE"
        echo '        <div class="stat-item">' >> "$OUTPUT_FILE"
        echo "            <div class=\"stat-value\">$LOG_COUNT</div>" >> "$OUTPUT_FILE"
        echo '            <div>Log Entries</div>' >> "$OUTPUT_FILE"
        echo '        </div>' >> "$OUTPUT_FILE"
        echo '        <div class="stat-item">' >> "$OUTPUT_FILE"
        echo "            <div class=\"stat-value\">${{ inputs.limit }}</div>" >> "$OUTPUT_FILE"
        echo '            <div>Max Limit</div>' >> "$OUTPUT_FILE"
        echo '        </div>' >> "$OUTPUT_FILE"
        echo '        <div class="stat-item">' >> "$OUTPUT_FILE"
        echo "            <div class=\"stat-value\">${{ inputs.output_format }}</div>" >> "$OUTPUT_FILE"
        echo '            <div>Format</div>' >> "$OUTPUT_FILE"
        echo '        </div>' >> "$OUTPUT_FILE"
        echo '    </div>' >> "$OUTPUT_FILE"
        
        # Add log entries
        if [[ "$LOG_COUNT" -gt 0 ]]; then
          echo "üîß Adding log entries to HTML"
          
          # Process each log entry individually to avoid complex escaping
          jq -c '.[]' raw_logs.json | while read -r entry; do
            TIMESTAMP=$(echo "$entry" | jq -r '.timestamp // "Unknown"')
            SEVERITY=$(echo "$entry" | jq -r '.severity // "INFO"')
            MESSAGE=$(echo "$entry" | jq -r '.textPayload // .jsonPayload // "No message"' | sed 's/</\&lt;/g; s/>/\&gt;/g')
            
            echo '    <div class="log-entry">' >> "$OUTPUT_FILE"
            if [[ "${{ inputs.include_metadata }}" == "true" ]]; then
              echo "        <div class=\"timestamp\">$TIMESTAMP</div>" >> "$OUTPUT_FILE"
              echo "        <span class=\"severity $SEVERITY\">$SEVERITY</span>" >> "$OUTPUT_FILE"
            fi
            echo "        <div class=\"message\">$MESSAGE</div>" >> "$OUTPUT_FILE"
            echo '    </div>' >> "$OUTPUT_FILE"
          done
        else
          echo '    <div class="no-logs">üì≠ No log entries found matching the specified criteria.</div>' >> "$OUTPUT_FILE"
        fi
        
        # Close HTML
        echo '</body>' >> "$OUTPUT_FILE"
        echo '</html>' >> "$OUTPUT_FILE"
        
        # Verify file creation and get size
        if [[ -f "$OUTPUT_FILE" ]]; then
          FILE_SIZE=$(stat -f%z "$OUTPUT_FILE" 2>/dev/null || stat -c%s "$OUTPUT_FILE" 2>/dev/null || echo "unknown")
          echo "‚úÖ HTML file created successfully: $OUTPUT_FILE (${FILE_SIZE} bytes)"
        else
          echo "‚ùå Failed to create HTML file"
          exit 1
        fi

    - name: Create JSON output
      if: ${{ inputs.output_format == 'json' }}
      shell: bash
      env:
        OUTPUT_FILE: ${{ steps.generate-filename.outputs.output_file }}
      run: |
        echo "üîß Creating JSON output file: $OUTPUT_FILE"
        
        if [[ "${{ inputs.include_metadata }}" == "true" ]]; then
          echo "üîß Creating JSON with full metadata"
          jq '.' raw_logs.json > "$OUTPUT_FILE"
        else
          echo "üîß Creating JSON with messages only"
          jq '[.[] | {
            message: (.textPayload // .jsonPayload // "No message"),
            timestamp: .timestamp
          }]' raw_logs.json > "$OUTPUT_FILE"
        fi
        
        # Verify file creation and get size
        if [[ -f "$OUTPUT_FILE" ]]; then
          FILE_SIZE=$(stat -f%z "$OUTPUT_FILE" 2>/dev/null || stat -c%s "$OUTPUT_FILE" 2>/dev/null || echo "unknown")
          ENTRIES=$(jq length "$OUTPUT_FILE" 2>/dev/null || echo "unknown")
          echo "‚úÖ JSON file created successfully: $OUTPUT_FILE (${FILE_SIZE} bytes, ${ENTRIES} entries)"
        else
          echo "‚ùå Failed to create JSON file"
          exit 1
        fi

    - name: Verify output and cleanup
      shell: bash
      env:
        OUTPUT_FILE: ${{ steps.generate-filename.outputs.output_file }}
      run: |
        echo "üßπ Performing final verification and cleanup..."
        
        # Final verification of output file
        if [[ ! -f "$OUTPUT_FILE" ]]; then
          echo "‚ùå Output file not found: $OUTPUT_FILE"
          exit 1
        fi
        
        # Get final file stats
        FILE_SIZE=$(stat -f%z "$OUTPUT_FILE" 2>/dev/null || stat -c%s "$OUTPUT_FILE" 2>/dev/null || echo "unknown")
        
        echo "üìã Final Output Summary:"
        echo "   üìÅ File: $OUTPUT_FILE"
        echo "   üìä Size: ${FILE_SIZE} bytes"
        echo "   üìÑ Format: ${{ inputs.output_format }}"
        echo "   üîç Filter: ${{ inputs.filter }}"
        
        # Cleanup temporary files
        rm -f raw_logs.json error.log 2>/dev/null || true
        
        echo "‚úÖ Log download and conversion completed successfully!"

branding:
  icon: 'download-cloud'
  color: 'blue'
