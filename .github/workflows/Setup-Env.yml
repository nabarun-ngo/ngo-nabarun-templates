name: 'Setup'
on:
  workflow_call:
    inputs:
      inputs:
        description: "All workflow_dispatch inputs as JSON string"
        type: string
        required: false
      client_payload:
        description: "repository_dispatch client payload as JSON string"
        type: string
        required: false
      script_path:
        description: "Path to shell script to execute (optional)"
        type: string
        required: false
      script_args:
        description: "Arguments to pass to the shell script (optional)"
        type: string
        required: false
    outputs:
      variables:
        description: "Merged input variables as JSON"
        value: ${{ jobs.set_env.outputs.variables }}

jobs:
  set_env:
    name : 'Set Variables'
    runs-on: ubuntu-latest
    outputs:
      variables: ${{ steps.set_vars.outputs.variables }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Schedule Configuration
        id: determine_config
        if: ${{ github.event_name == 'schedule' }}
        uses: ./.github/actions/determine-schedule-config

      - name: Resolve and Export Inputs
        uses: nabarun-ngo/ngo-nabarun-templates/.github/actions/resolve-inputs@main
        with:
          inputs: ${{ inputs.inputs }}
          client_payload: ${{ inputs.client_payload }}
          schedule_config_file: ${{ steps.determine_config.outputs.config_file }}

      - name: Print all environment variables
        shell: bash
        run: |
          echo "===== All Env Vars (Before Script) ====="
          env
          echo "========================================"
          
      # This script can set variables or output JSON that will be merged with configuration
      - name: Execute Shell Script
        if: ${{ inputs.script_path != '' }}
        id: execute_script
        shell: bash
        run: |
          set -euo pipefail
          
          script_path="${{ inputs.script_path }}"
          script_args="${{ inputs.script_args }}"
          
          echo "üöÄ Executing script: $script_path"
          if [[ -n "$script_args" ]]; then
            echo "üìù Script arguments: $script_args"
          fi
          
          chmod +x "$script_path"
          
          # Execute the script with arguments (if provided)
          if [[ -n "$script_args" ]]; then
            eval "\"$script_path\" $script_args" || {
              echo "‚ùå Script execution failed with exit code $?"
              exit 1
            }
          else
            "$script_path" || {
              echo "‚ùå Script execution failed with exit code $?"
              exit 1
            }
          fi
          
          echo "‚úÖ Script execution completed successfully"

      - name: Capture and Process Script Output
        if: ${{ inputs.script_path != '' }}
        id: process_script_output
        shell: bash
        run: |
          set -euo pipefail
          
          echo "üìÑ Processing script output and environment variables..."
          
          # Initialize script JSON
          script_json='{}'
          
          # Check if script set any JSON output in environment
          if [[ -n "${SCRIPT_JSON_OUTPUT:-}" ]]; then
            echo "üìä Found SCRIPT_JSON_OUTPUT environment variable"
            if echo "$SCRIPT_JSON_OUTPUT" | jq empty 2>/dev/null; then
              script_json="$SCRIPT_JSON_OUTPUT"
              echo "‚úÖ Valid JSON found in SCRIPT_JSON_OUTPUT"
            else
              echo "‚ö†Ô∏è Invalid JSON in SCRIPT_JSON_OUTPUT, ignoring"
            fi
          fi
          
          # Look for variables that start with SCRIPT_ (excluding SCRIPT_JSON_OUTPUT)
          echo "üîç Looking for SCRIPT_* environment variables..."
          script_vars_json='{}'
          while IFS= read -r line; do
            if [[ "$line" =~ ^SCRIPT_([A-Za-z0-9_]+)=(.*)$ ]] && [[ "$line" != "SCRIPT_JSON_OUTPUT="* ]]; then
              var_name="${BASH_REMATCH[1]}"
              var_value="${BASH_REMATCH[2]}"
              
              echo "Found script variable: $var_name = $var_value"
              
              # Determine value type and add to JSON
              if [[ "$var_value" =~ ^[0-9]+$ ]]; then
                # Integer
                script_vars_json=$(echo "$script_vars_json" | jq --arg k "$var_name" --argjson v "$var_value" '. + {($k): $v}')
              elif [[ "$var_value" =~ ^[0-9]+\.[0-9]+$ ]]; then
                # Float
                script_vars_json=$(echo "$script_vars_json" | jq --arg k "$var_name" --argjson v "$var_value" '. + {($k): $v}')
              elif [[ "$var_value" =~ ^(true|TRUE|false|FALSE)$ ]]; then
                # Boolean
                bool_value=$(echo "$var_value" | tr '[:upper:]' '[:lower:]')
                script_vars_json=$(echo "$script_vars_json" | jq --arg k "$var_name" --argjson v "$bool_value" '. + {($k): $v}')
              else
                # String
                script_vars_json=$(echo "$script_vars_json" | jq --arg k "$var_name" --arg v "$var_value" '. + {($k): $v}')
              fi
            fi
          done <<< "$(env | grep '^SCRIPT_' || true)"
          
          # Merge script JSON and script variables
          if [[ "$script_vars_json" != "{}" ]]; then
            echo "‚úÖ Found script variables: $script_vars_json"
            script_json=$(echo "$script_json $script_vars_json" | jq -s 'add')
          fi
          
          # Set final script JSON output
          echo "script_json=$script_json" >> "$GITHUB_OUTPUT"
          echo "FINAL_SCRIPT_JSON=$script_json" >> "$GITHUB_ENV"
          
          echo "üìà Final script JSON: $script_json"

      - name: Print all environment variables
        shell: bash
        run: |
          echo "===== All Env Vars (After Script) ====="
          env
          echo "========================================"

      - name: Resolve Configuration and Merge Script Output
        id: set_vars
        shell: bash
        run: |
          set -euo pipefail
          
          echo "üîÑ Resolving configuration and merging script output..."
          
          # First, resolve the base configuration using the resolve-inputs action logic inline
          echo "‚öôÔ∏è Resolving base configuration..."
          
          # Detect trigger type
          event_name="${{ github.event_name }}"
          echo "Trigger type: $event_name"
          
          # Initialize configuration data
          config_json='{}'
          
          case "$event_name" in
            "workflow_dispatch")
              echo "üìù Processing workflow_dispatch trigger"
              inputs_json='${{ inputs.inputs != '' && inputs.inputs || toJson(github.event.inputs) }}'
              if [[ "$inputs_json" != "null" && "$inputs_json" != "{}" && ! -z "$inputs_json" ]]; then
                config_json="$inputs_json"
                echo "‚úÖ Using workflow_dispatch inputs"
              fi
              ;;
              
            "repository_dispatch")
              echo "üöÄ Processing repository_dispatch trigger"
              payload_json='${{ inputs.client_payload != '' && inputs.client_payload || toJson(github.event.client_payload) }}'
              if [[ "$payload_json" != "null" && "$payload_json" != "{}" && ! -z "$payload_json" ]]; then
                config_json="$payload_json"
                echo "‚úÖ Using repository_dispatch payload"
              fi
              ;;
              
            "schedule")
              echo "‚è∞ Processing schedule trigger"
              config_file="${{ steps.determine_config.outputs.config_file }}"
              if [[ -n "$config_file" && -f "$config_file" ]]; then
                current_schedule="${{ github.event.schedule }}"
                echo "üìÖ Current schedule: $current_schedule"
                schedule_config=$(cat "$config_file" | jq -c --arg schedule "$current_schedule" '.[$schedule] // {}')
                if [[ "$schedule_config" != "{}" ]]; then
                  config_json="$schedule_config"
                  echo "‚úÖ Found config for schedule '$current_schedule'"
                fi
              fi
              ;;
          esac
          
          # Ensure config_json is valid
          config_json=$(echo "$config_json" | jq -c '.' || echo '{}')
          echo "üìÑ Base configuration: $config_json"
          
          # Get script output (safely handle when no script was executed)
          script_json='{}'
          if [[ "${{ inputs.script_path }}" != "" ]]; then
            # Script was provided, check if process_script_output step ran and produced output
            script_output_raw="${{ steps.process_script_output.outputs.script_json }}"
            if [[ -n "$script_output_raw" && "$script_output_raw" != "null" && "$script_output_raw" != "" ]]; then
              script_json="$script_output_raw"
              echo "üìÑ Script output found: $script_json"
            else
              echo "‚ÑπÔ∏è No script output captured"
            fi
          else
            echo "‚ÑπÔ∏è No script was executed"
          fi
          
          # Merge configuration with script output (script takes precedence)
          if [[ "$script_json" != "{}" && -n "$script_json" ]]; then
            echo "‚úÖ Merging script output with base configuration"
            final_json=$(echo "$config_json $script_json" | jq -s 'add')
          else
            echo "‚ÑπÔ∏è Using base configuration as final result"
            final_json="$config_json"
          fi
          
          # Validate final JSON
          if echo "$final_json" | jq empty 2>/dev/null; then
            echo "‚úÖ Final JSON is valid"
          else
            echo "‚ùå Final JSON is invalid, using empty object"
            final_json='{}'
          fi
          
          echo "üìà Final variables JSON: $final_json"
          
          # Set output
          echo "variables=$final_json" >> "$GITHUB_OUTPUT"
          
          # Also export individual variables to environment
          if [[ "$final_json" != "{}" ]]; then
            echo "$final_json" | jq -r 'to_entries | map("\(.key)=\(.value|tostring)") | .[]' >> "$GITHUB_ENV"
          fi

